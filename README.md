# hello_nasm

"Знакомимся с инструментом
Чтобы писать программы на языке ассемблера, нужно изучить, во-первых, процессор, с которым мы будем работать (пусть не все его возможности, но хотя бы некоторую существенную их часть), и, во-вторых, синтаксис языка ассемблера. К сожалению, здесь возникает определенная проблема: изучать эти две вещи одновременно не получается, но изучать систему команд процессора, не имея никакого представления о синтаксисе ассемблера, а равно и изучать синтаксис, не имея представления о системе команд - задача неблагодарная. Мы попробуем пойти иным путем: для начала составим хоть какое-то представление как о системе команд, так и о синтаксисе языка, пусть даже это представление будет поверхностным, а затем уже приступим к систематическому изучению того и другого.
Для начала напишем работающую программу, оттранслируем ее и запустим. Задачу выберем очень простую - вывести в поток стандартного вывода пять раз слово «Hello». Для вывода строки на экран, а также для корректного завершения программы нам потребуется обращаться к операционной системе, но мы пока воспользуемся для этого готовыми макросами, которые описаны в отдельном файле. Ассемблер, сверяясь с этим файлом и с нашими указаниями, преобразует каждое использование такого макроса во фрагмент кода на языке ассемблера и сам же эти фрагменты затем оттранслирует.
Машинные команды в языке ассемблера обозначаются удобными для запоминания короткими словами, так называемыми мнемониками. Кроме мнемоник, также встречаются директивы, то есть прямые приказы ассемблеру, и макровызовы, задействующие возможности макросов.
Первая строчка программы содержит директиву «%include», которая предписывает ассемблеру вставить на место самой директивы все содержимое некоторого файла, в данном случае - «stud_io.inc». Этот файл также написан на языке ассемблера и содержит описание макросов PRINT, PUTCHAR и FINISH, которые мы будем применять соответственно для печати строки, для перехода на следующую строку на экране и для завершения программы. Увидев и выполнив директиву «%include», ассемблер прочитает файл с описаниями макросов, что позволит нам их использовать.
Важно отметить, что директива «%include» обязательно должна стоять в тексте программы раньше, чем там встретятся имена макросов. Ассемблер просматривает текст сверху вниз. Изначально он ничего не знает о макросах и не сможет их обработать, если ему о них не сообщить. Просмотрев файл, содержащий описания макросов, ассемблер запоминает эти описания и продолжает их помнить для окончания трансляции.
Далее мы видим строку, начинающуюся со слова «global» — это тоже директива, о которой чуть позже.
Следующая строка содержит директиву «section»; попробуем объяснить ее смысл. Исполняемый файл в ОС Unix устроен так, что в нем машинные команды хранятся в одном месте, а инициализированные данные (то есть такие, которым прямо в программе задается начальное значение) - в другом, и, наконец, в третьем месте содержится информация о том, сколько программе потребуется памяти под неинициализированные данные. Соответствующие части исполняемого файла как раз и называются секциями. При загрузке исполняемого файла в память, ОС создает отдельные области памяти (так называемые сегменты) для машинного кода (взяв за основу нашу секцию, содержащую машинный код), для данных (здесь объединяются инициализированные и неинициализированные данные; в общем случае сегмент может состоять из нескольких секций) и для стека (этому сегменту никакие секции не соответствуют).
Ассемблер на основе текста нашей программы формирует отдельные образы (то есть будущее содержимое памяти) для каждой из секций; мы должны наш исполняемый код поместить в одну секцию, описание областей памяти с заданным начальным значением - в другую секцию, описание областей памяти без заданных начальных значений - в третью. Соответствующие секции называются «.text», «.data», «.bss». Секцию стека ОС формирует без нашего участия, так что она в программах на языке ассемблера не упоминается. 
В нашей простой программе мы обходимся только секцией «.text»; рассматриваемая директива приказывает ассемблеру приступить к формированию этой секции. В будущем при рассмотрении более сложный программ нам придется встретиться со всеми тремя секциями.
Далее следует строка: «_start: mov eax, 0». Словом «mov» обозначается команда, заставляющая процессор переслать некоторые данные из одного места в другое. После команды указаны два параметра, которые называются операндами; здесь первый операнд задает, куда следует скопировать данные, а второй операнд указывает, какие данные следует туда скопировать. В данном конкретном случае команда требует занести число «0» в регистр «EAX». Значение, хранимое в этом регистре, мы будем использовать в качестве счетчика цикла, то есть оно будет означать сколько раз мы уже напечатали слово «Hello»; ясно, что в начале выполнения программы этот счетчик должен быть равен нулю, поскольку мы пока не напечатали ничего.
Слово «_start» — это так называемая метка.
Команду «mov eax, 0» ассемблер преобразует в машинный код. Отметим для наглядности, что для рассматриваемой команда это код состоит из пяти байтов: «b8 00 00 00 00», первый из которых задает собственно действие «поместить заданное число в регистр» и номер этого регистра. Остальные четыре байта все вместе задают число, которое должно быть помещено в регистр. Во время выполнения программы этот код будет находиться в какой-то области оперативной памяти, в пяти ячейках, идущих подряд. В некоторых случаях нам нужно знать, какой адрес будет иметь та или иная область памяти; если говорить о командах, то адрес нам может потребоваться, например, чтобы в какой-то момент заставить процессор передать управление в это место программы (то есть сделать сюда условный или безусловный переход).
Конечно, в оперативной памяти можно хранить не только команды, но и данные. Области памяти, предназначенные для данных, мы обычно называем переменными и даем им имена. Естественно, нам требуется знать, какой адрес имеет начало области памяти, отведенной под переменную. Запоминать числа адресов неудобно, к тому же на момент написания программы мы еще не знаем, в каком именно месте памяти в итоге окажется размещена та или иная команда или переменная. И здесь нам на помощь как раз и приходят метки. Метка — это вводимое программистом слово (идентификатор), с которым ассемблер ассоциирует некоторое число, чаще всего - адрес в памяти, но не всегда. В данном случае «_start» как раз и есть метка, связанная с адресом в памяти. Если ассемблер видит метку перед командой (или, как мы увидим позже, перед директивой, выделяющей память под переменную), он воспринимает это как указание завести в своих внутренних таблицах новую метку и связать с ней соответствующий адрес, если же метка встречается в параметрах команды, то ассемблер вспоминает, какой именно адрес (или просто число) связано с данной меткой и подставляет этот адрес вместо метки в команду. Так с меткой «_start» в нашей программе будет связан адрес ячейки, начиная с которого в оперативной памяти будет размещен машинный код, соответствующей команды.
Важно понимать, что метки существуют в памяти самого ассемблера во время трансляции программы, некоторые продолжают существовать во время работы редактора связей, но готовая к исполнению программа, представленная в машинном коде, не будет содержать никаких меток, а только подставленные вместо них адреса.
После метки в обсуждаемой строке стоит символ двоеточия. Но мы могли бы его и не ставить. Некоторые ассемблеры отличают метки, снабженные двоеточиями, от тех, которые без них. Но наш NASM к таким не относится, здесь мы сами решаем ставить двоеточие или нет. Обычно программисты ставят двоеточия после меток, которыми помечены машинные команды (то есть после таких меток, куда можно передать управление), но не ставят двоеточия после меток, помечающих данные в памяти (переменные). Поскольку «_start» помечает команду, после нее двоеточие мы решили поставить.
Еще один очень важный момент заключается в том, что «_start» — это специальная метка, которой помечается точка входа в программу, то есть то место в программе, куда операционная система должна передать управление после загрузки программы в оперативную память. Другими словами место, с которого начнется выполнение программы. 
Следующая строка: «again: PRINT “Hello”». Здесь, как не сложно догадаться слово «again» (снова) — это еще одна метка. Чтобы «Hello» было напечатано пять раз нам придется еще четыре раза вернуться в эту точку программы. Стоящее далее в строке слово «PRINT» является именем макроса, а строка «Hello», которую мы хотим вывести, - параметром этого макроса.
Очень важно понимать, что «PRINT» не имеет никакого отношения к возможностям ЦП. То есть это не имя какой-либо команды, но директива, также называемая - макровызовом. Повинуясь этой директиве, ассемблер сформирует фрагмент текста и сам же его оттранслирует, получив последовательность машинных инструкций. Эти инструкции будут содержать, в числе прочего, обращение к операционной системе за услугой вывода данных (системный вызов «write»).
Следующая строка имеет вид: «PUTCHAR 10» — это тоже вызов макроса, предназначенного для вывода на печать одного символа (10 - код символа перевода строки). В этой и последующих строках присутствуют только команды и макровызовы, а меток нет. Они нам не нужны, поскольку ни на одну из последующих команд мы не собираемся делать переходы, и, значит, нам не нужна информация об адресах в памяти, где будут располагаться эти команды.
Далее строка: «inc eax». Здесь мы видим машинную команду «inc», означающую приказ увеличить заданный регистр на «1». Это позволит нам вести учет количества выводов строки на экран.
Следом идет строка: «cmp eax, 5» - машинная команда сравнения двух целых чисел (compare). В данном случае сравнивается содержимое регистра с числом. Результаты сравнения записываются в специальный регистр процессора, называемый регистром флагов. Это позволяет, в частности, произвести условный переход в зависимости от результатов предшествующего сравнения.
Следующая строка: «jl again» (jump if less) — это мнемоника для машинной команды условного перехода на соответствующую метку, который выполняется в случае, если предшествующее сравнение дало результат «первый операнд меньше второго». Если результат сравнения был любым кроме «меньше», то процессор перейдет к выполнению следующей по порядку программы.
Последняя строка «FINISH» - вызов макроса, который разворачивается в последовательность команд, выполняющих обращение к ОС с просьбой завершить выполнение программы.
Осталось вернуться к началу и рассмотреть строку: «global _start». Слово «global» — это директива, которая требует от ассемблера считать некоторую метку «глобальной», то есть как бы видимой из вне. В данном случае глобальной является метка «_start»." 
Автор: Столяров Андрей Викторович
